# SSL Pinning
SSL Pinning is a security methodology used to ensure that application traffic is not intecepted (MITM)
- application verify that the received traffic is coming from a known certificate
- we can import a certificate into the phone as a root or user certificate but it could be not trusted by application
- this can cause our application to crash when we try to intercept the netword traffic



We could use two proxies:
- burpsuite
- proxyman


## android interception Process
1. start the proxy 
2. configure it
3. set the proxy of the emulator
4. intercept HTTP traffic
5. import CA certificate
6. trust CA certificate in Android Certificate Store
7. Intercept HTTPS traffic
	1. if is blocked by ssl pinning use objection / frida


## Dynamic analysis with MobSF 
To start the dynamic analysis with MobSF we have to configure it (android studio emulaor):

1. Add to PATH variable
	1. `export PATH=$PATH:/home/cristian/Android/Sdk/emulator`
2. see the list of emulators
	1. `emulator -list-avds`
3. run the emulator (choose one that supports root)
	1.  `emulator -avd Nexus_5_API_23 -writable-system -no-snapshot`



==**NOT WORKING**==

Now we have to start the docker of MobSF adding the emulator:
1. search for emulator number
	1. ![[Pasted image 20240319172426.png]]
2. run the docker:
	1. ` sudo docker run -it -e "MOBSF_ANALYZER_IDENTIFIER=emulator-5556" --rm -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest`





<mark style="background: #BBFABBA6;">WORKING PROCEDURE: (after running the emulator with the command emulator)</mark>
```shell
sudo ./run.sh
```




## burp suite

Go on burp:
- proxy -> proxy settings -> add -> add a new proxy with a port such as 8082 -> all interfaces (IMPORTANT)

Now we have to add the proxy in the emulator:
- 3 points -> settings -> proxy -> manual proxy -> add an address (maybe 127.0.0.1) -> add the port used on burp (8082)





IMPORTANTE:
Con gli emulatori nuovi non funziona quindi dobbiamo fare il revert a 33.1.1 
- https://developer.android.com/studio/emulator_archive?hl=it

Per scaricare apri con f12 la console e clicca sul banner 33.1.1, vedi che sotto c'Ã¨ una div con i link di download.

Scarica la versione 33.1.1 -> vai nella cartella Android/Sdk -> rinomina la cartella emulator in emulator_original -> unzip del download nella cartella Android/Sdk -> copia il file package.xml della cartella emulator_original in emulator -> aprilo e cambia < revision>< major>31< /major>< minor>1< /minor>< micro>1< /micro>< /revision>



Now we need a certificate:
- proxy settings -> import/export CA certificate -> export in DER format -> proxy_certificate.CER -> drop it into the android emulator (drag and drop)
- in emulator go to settings -> security -> credential store -> install from sd card -> search for the name of the certificate -> VPN and apps




Now it works!


# Proxyman (only on MacOS)

Proxyman is a software used to intercept the traffic of emulators. It works by default on port `9090`

First thing to do is to go on 
`Certificate` -> `Install certificate on Android` -> `Emulators/Physical` -> `Override Emulator`

Then we need to change the proxy on the emulator.


`Settings` -> `Proxy` -> `put the proxyman IP and port`



To see the certificate what we need is to go on the emulator:
- `Settings` -> `Security` -> `Trusted credentials` -> `User`  and then cliclk on it and `Trust`


# App patching
## Automatically with objection

1. We have to run our emulator
2. install frida tools
	1. `pip3 install frida-tools`
3. install objection (after frida)
	1. `pip3 install objection`


At this point we can use the command line to patch apps automatically:
```shell
objection patchapk --source file.apk
```

It will detect automatically the architecture, will install automatically the frida gadgets on the device and recompile and sign the app.

**==It will create a new apk we can install.==**

Sometime it has errors in certificate parsing and we need to do manually the process.


## Manually 
objection -g 'Application Name' explore
ios sslpinning dis
First thing to do is to disassemble the apk code using:
```shell
apktool d -r file.apk
```



Now we can go in the `lib` folder to see the architectures. **==According to the architecture of our device we need to inject the folder with his architecture.==**
- ![[Pasted image 20240702112349.png]]


## Frida download 
Go to [https://github.com/frida/frida/releases](https://github.com/frida/frida/releases) and download `frida-gadget-... architecture.so.zx`.
- the version for our device architecture


Now we will paste the extracted file into the `lib` folder ( in our architecture folder ).
- in some cases we need to add `lib` before the name, so `libfrida...`


At this point we need to add these lines to the smali file of the main activity:
```smali
const-string v0, "frida-gadget (the name of the library we injected)" invoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V
```
- The file `MainActivity.smali` can be found in `smali` folder
- We need to add these lines into the constructor method:
	- ![[Pasted image 20240702113147.png]]

If the `Manifest.xml` has no internet permission we need to add them:
```xml
<user-permission android:name="android.permission.INTERNET"/>
```

Now we need to rebuild the injected apk:
```shell
apktool b file.apk -o output.apk
```



The last phase is to resign the apk.

Key generation:
```shell
keytool -genkey -v -keystore custom.keystore -alias alias_we_want -keyalg RSA -keysize 2048 -validity 10000
```
- add random info when required

Apk signer:
```shell
jarsigner -sigalg SHA1withRSA -digestalg SHA1 -keystore our_key.key -storepass password_we_want file.apk alias_of_our_key
```


Verify the signing:
```shell
jarsigner -verify file.apk 
```


Sometimes it happens that the signed apk is not aligned and it could be not installed, so we need to align it:
```shell
zipalign 4 file.apk final_file.apk
```



At this point we can install and open the apk on the device.
If it shows a white screen it is good.

To start to use the app and objection we have to run on therminal:
```shell 
objection explore
```



Now we can use objection and all usable features.

For example SSL pinning:
```shell
android sslpinning disable/enable
```




# Frida codeshare

Frida codeshare can be used to take scripts written by other users to perform additional operations.

we can access on it using [https://codeshare.frida.re/](https://codeshare.frida.re/)

**==To use them we need to copy the script and store it in the apk folder.==**
- we need to save it as `.js`


To call these script we can do:
```shell
objection explore --startup-script script_name.js
```


If we receive the error `invalid resource` we can resolve using:
```shell
objection patchapk -s file.apk --use-aapt2
```




# Final notes

With objection we can do varius things.

We just need to write `android` and see what we can use clicking on tab.

## sslpinning disable to intercept traffic

We can use:
```shell
objection explore
```
```shell
android sslpinning disable
```
## dump memory with objection

We can use:
```shell
memory dump all/other options
```

## methods hooking
To hook a methid and see what it does we can use:
```shell
android hooking
```


## key listing
To list the key stored by the application  we can use:
```shell
android keystore list
```


# root detection disable

TO disable the root detection we can use:
```shell
android root disable
```
And so on...




# Multiple apk for an application

When we have multiple apk for an application we have to patch the base apk but we need to sign all the apks used to install the app:
- ![[Pasted image 20240702150827.png]]

We can sign them (after injected the base apk) using:
```shell
objection signapk apk_to_sign
```
- ![[Pasted image 20240702150926.png]]


After it we can install multiple apks using `adb`
```shell
adb install-multiple objection_apk_1  objection_apk_2 ... 
```





