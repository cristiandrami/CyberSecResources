In this section we will use:
- `PMAT-labs/labs/3-3.OffScript-ScriptMalware/HTA/Dropper.hta.7z`

HTAs are commonly used as the payload of phishing attacks. .


HTAs are Windows-executable, packaged HTML files that run HTML, CSS, and Windows native scripting languages from a single file outside of the context of the web browser. 

**HTAs do not run in the context of the Windows web browser, but instead run as a trusted application on the operating system.**

## Static Analysis
Recall that an HTA is still, under the hood, HTML in a single file. Let’s open this file in Visual Studio Code to examine the HTML located within it:

```html
<html>
	<head>
	<title></title>
	<body>
		<script language="JavaScript" type="text/javascript">
document.write(unescape('%3c%68%74%6d%6c....[snip]......'));
		</script>
	</body>
</html>
```
- `document.write()`: The `write()` method writes directly to an open (HTML) document stream.
- `unescape():` The **unescape()** function computes a new string in which hexadecimal escape sequences are replaced with the characters that they represent.

Using CyberChef, we add the `From Hex` decoder and change the delimiter to `Percent`. Then, we copy the block of hex bytes into the Input section:
- ![[Pasted image 20250212111833.png]]


The output is:
- ![[Pasted image 20250212111849.png]]


The VBScript code starts by setting up the required parameters to invoke Windows Management Instrumentation (WMI) to execute a process. 

The VBScript then performs:
- ![[Pasted image 20250212111946.png]]

The process argument here runs a command shell which, in turn, runs PowerShell in a hidden window. When PowerShell is executed, it performs the following:
- ![[Pasted image 20250212112008.png]]

If we take a step back, we now have a clear idea of the execution chain here:
1. HTA is opened and runs the embedded JavaScript.
2. The JavaScript decodes the hex bytes of an inner HTML document and writes it into the HTA.
3. The inner HTML document invokes VBScript to execute WMI.
4. WMI runs a process to call a command shell.
5. The command shell, in turn, runs PowerShell in a hidden window.
6. PowerShell runs a download cradle command to reach out to `[http://tailofawhale.local/TellAndSentFor.exe](http://tailofawhale.local/TellAndSentFor.exe)`, write it to the %temp% directory as `jLoader.exe` and then execute `jLoader.exe`

## Dynamic Analysis

When we open the HTA program, a window flashes for a moment and then disappears. If we are running INetSim at the time of detonation, we see the default INetSim binary spawn. Take note of the location where the binary is running from:
- ![[Pasted image 20250212112129.png]]

In WireShark, we see the outbound DNS request for `tailofawhale.local` and its DNS resolution:
- ![[Pasted image 20250212112150.png]]


If we go to examine host-based indicators, we run into a small snag. There is no process called “Dropper.hta” anywhere in the list of running processes on the host. Where does this process execute?

HTAs do not execute directly. When double-clicked, they are passed to the native Windows binary `mshta.exe` which executes them on its behalf. `mshta.exe` acts as an HTML interpreter and loads the HTML from the HTA along with any DLLs that deal with script execution and then executes the program all at once.

If we look in the Procmon process tree after detonation, we see an invocation of `mshta.exe` that takes the path to our HTA sample as its argument:
- ![[Pasted image 20250212112703.png]]


Higher up in the process list, there is an instance of `svchost.exe` that is executing a process called `wmiprvse.exe`. This is the way that Windows invokes WMI to execute processes:
- ![[Pasted image 20250212112731.png]]


We can follow the `wmiprvse.exe` process all the way down through the call to PowerShell and, eventually, the execution of the `jLoader.exe` program. In this case, this was our INetSim default binary that spawned the message box, but in real life this is likely a second stage payload.

