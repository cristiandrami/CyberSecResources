

# x86 CPU instructions
There are 3 types of cpu instructions we will see that are basically:
1. `mov`, that is a data moving instruction
2. `jmp`, that is a control flow instruction
3. `sub`, arithmetical subtraction isntruction

## mov
When we use it we are moving data from a register to another.

```c 
mov edx, eax
```
- `eax` is the source register
- `edx` is the destination register
- we are copying the content of `eax` into `edx`


# jmp
`jmp` instruction is used to jump form a memory location to another, basocally is used to jump to an instruction (when we have an `if` we use the `jmp`)
- ![[Pasted image 20250207162240.png]]


Another instruction is `jnz` that is `jump if not zero`.
- In this case we jump to a n address only if the content of a register is not 0, otherwise we jump to another address
- ![[Pasted image 20250207162408.png]]


## **SUB Instruction**

The `sub` instruction is used to subtract one value from another and store the result in the destination register.

```c
sub edx, eax
```
- `eax` is the value being subtracted
- `edx` is the destination register 
- The content of `eax` is subtracted from `edx`, and the result is stored in `edx`


## PUSH and POP Instructions

The `push` and `pop` instructions are used to manage data in the **stack**, a special memory structure that follows the **Last In, First Out (LIFO)** principle.

### What is the Stack?

The stack is a reserved area in memory used to store temporary data, such as function parameters, return addresses, and register values. It grows downward in memory, meaning that new data is added at lower memory addresses.
- ![[Pasted image 20250207162924.png]]



### **PUSH Instruction**
The `push` instruction **saves a value onto the stack**, decreasing the stack pointer (`ESP` or `RSP` in 64-bit systems).

```C
push eax
```
- The value in `eax` is placed on top of the stack.
- The stack pointer is adjusted accordingly.

*For example we do*:
```C
push 0, string, 12
```
- ![[Pasted image 20250207163014.png]]

### **POP Instruction**
The `pop` instruction **retrieves a value from the stack**, increasing the stack pointer.
```C
pop ebx
```
- The top value from the stack is loaded into `ebx`
- The stack pointer is adjusted to remove the retrieved value.

### **Example of PUSH and POP in Action**
```assembly
push eax ; Save eax on the stack 
push ebx ; Save ebx on the stack 
pop eax ; Restore the last pushed value into eax (was ebx) 
pop ebx ; Restore the next value into ebx (was eax)
```


## **CALL and RET Instructions**

The `call` and `ret` instructions are used for **function calls** in Assembly, allowing the program to jump to a subroutine and return once it's finished. These instructions rely on the **stack** to manage return addresses.

### **CALL Instruction**
The `call` instruction is used to **jump to a function (subroutine)** while saving the return address on the stack.
```c
call myFunction
```
- The address of the next instruction (after `call`) is pushed onto the stack.
- Execution jumps to `myFunction`.

### **RET Instruction**
The `ret` instruction is used to **return from a function** by restoring the saved return address from the stack.

```c
ret
```
- The return address is popped from the stack.
- Execution resumes at the instruction after the original `call`.

## Example of CALL and RET
```C
section .text 
    global _start 
    
_start: 
	call myFunction ; Call the function 
	mov eax, 1 ; Exit the program 
	int 0x80 

myFunction: 
	mov eax, 42 ; Some function logic 
	ret ; Return to caller
```

*For example we call `checkURL` from main*:
- ![[Pasted image 20250207163545.png]]
	- it executes the function and returns to the instruction after the call in the main
### **How CALL and RET Work with the Stack**

1. `call myFunction` pushes the return address onto the stack.
2. Execution jumps to `myFunction`.
3. `ret` pops the return address from the stack and resumes execution at the original location.


This mechanism ensures that after a function completes, the program continues from where it left off.



# Memory register 
Memory registers store and manipulate data in the CPU. In x86 and x86-64 assembly, there are different types of registers categorized by their function.

### **1. General-Purpose Registers (GPRs)**

These are used for arithmetic, logic, and data movement operations.

#### **32-bit (x86) Registers**

|Register|Purpose|Notes|
|---|---|---|
|`EAX`|Accumulator|Used in arithmetic and function return values|
|`EBX`|Base Register|Often used to store base addresses|
|`ECX`|Counter Register|Used in loops and string operations|
|`EDX`|Data Register|Used in multiplication and I/O operations|
|`ESI`|Source Index|Used in memory operations (e.g., string copying)|
|`EDI`|Destination Index|Used in memory operations|
|`EBP`|Base Pointer|Points to the base of the stack frame|
|`ESP`|Stack Pointer|Points to the top of the stack|
