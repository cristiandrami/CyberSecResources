In this section we will use:
- `PMAT-labs\\labs\\2-5.AntiAnalysis\\1.simpleAntiAnalysis`

# Anti-analysis Techniques
Anti-analysis is the broad term for a multitude of techniques that malware authors use to disrupt the malware analysis process. Anti-analysis can be as general as obfuscation.

But more specifically, anti-analysis also means when a malware author puts special code in a malware sample to detect when it is being examined and deter the examination.


## IsDebuggerPresent() API Call
This technique is a naive form of anti-analysis in which the malware sample detects the presence of a debugger that is attached to its process.
- ![[Pasted image 20250211104914.png]]
- ![[Pasted image 20250211104939.png]]

This function puts 1 into `eax` if the debugger is detected, 0 otherwise.

Then, the program performs a bitwise `AND` of the value of `eax`. 
The bitwise `AND` of `eax` will set the Zero Flag (ZF) to 1 or 0.

Then the program performs a `SETNE` `AL` (**SET** If **N**ot **E**qual To) instruction call.

Simply put, `SETNE AL` sets the value of `AL` (the lower bits of `eax`) to 1 or 0 depending on if the Zero Flag is clear or not. Here, the program has determined if a debugger is present based on the return value of the `IsDebuggerPresent()` call and is now prepping the memory registers to jump to another set of instructions.

`JNE` controlled the flow of the program based on if the Zero Flag was set to 1 or 0. In this program, we have a similar instruction, which is `JE [Memory Location]` (**J**ump if **E**qual To). JE evaluates the Zero Flag and acts as the inverse instruction: **if the Zero Flag is equal to 1, the jump is taken.** If the Zero Flag is equal to 0, the jump is not taken.
- ![[Pasted image 20250211105307.png]]


## Defeating Simple Anti-analysis
To bypass it we can use `x32dbg`  and find the instruction that performs the `IsDebuggerPresent()`.

In the String search panel, enter: `IsDebuggerPresent`
- ![[Pasted image 20250211105431.png]]
- The string `IsDebuggerPresent`” is passed to the `LoadLibrary` and `GetProcAddress` functions so it can be resolved and used when the program runs.
- **Set a breakpoint on this string reference (F2).**

Return to the CPU panel and continue the execution of the program by pressing F9. We eventually hit out breakpoint:
- ![[Pasted image 20250211105532.png]]

The string reference for `IsDebuggerPresent` is currently being resolved, so we’re close to where we want to be. Continue to step through the program with `F8` until you return from this call:
- ![[Pasted image 20250211105611.png]]

After returning from this call, we are here in the program (**I recommend setting a breakpoint here!**):
- ![[Pasted image 20250211105632.png]]

Notice how when RIP is on the jump instruction, the Zero Flag is cleared (set to 0):
- ![[Pasted image 20250211105708.png]]


Double click on the Zero Flag to flip it to a 1:
- ![[Pasted image 20250211105728.png]]
- ![[Pasted image 20250211105740.png]]

