In this case we will use:
- `PMAT-labs\labs\3-2.WhatTheShell-ShellcodeAnalysis\CarveFromMemory`


# PEstudio on the file
We use `PEstudio` on the file in order to get some info about it:
- ![[Pasted image 20250211162207.png]]

We can see useful info.

It could be possible that it writes on the memory a shell code in order to execute it.

So we open the file with `Cutter`:
- ![[Pasted image 20250211162716.png]]
We don't find the `main` function but we follow the entry.

The main function is put into the `eax` at some point:
- so we click on the second call
- ![[Pasted image 20250211162844.png]]
- ![[Pasted image 20250211162859.png]]

So now we go on the end of the tree:
- ![[Pasted image 20250211162926.png]]
- and we can see a `mov eax` with an address

So if we go upper we can notice that the same address is moved into the eax before:
- ![[Pasted image 20250211163148.png]]

So we can assume the call before is the main function:
- ![[Pasted image 20250211163211.png]]


This because the value is returned in the last part of the flow to the operating system and that value is put from the call to that function (main) into the eax then that function is the main function.

So we rename it:
- ![[Pasted image 20250211163511.png]]


At this point we study the last call in it:
- ![[Pasted image 20250211163553.png]]
- Since is `OpenProcess`

And we have an interesting `WriteProcessMemory`:
- ![[Pasted image 20250211163622.png]]
- We copy his memory address `0x0040170a`

We will use `x64dbg` with the copied address:
- using `CTRL + G` we put the address of the API call
- ![[Pasted image 20250211164241.png]]
- ![[Pasted image 20250211164252.png]]

Here with `F2` we put a breakpoint:
- ![[Pasted image 20250211164352.png]]

At this point we run the progrma until the breakpoint:
- ![[Pasted image 20250211164429.png]]

Now for sure in the registers we have the shellcode:
- ![[Pasted image 20250211164503.png]]
- from the docuemntation of the API call we know we have to search the `lpBuffer` to retrieve the content of the shellcode

So the actual call of the API is the instruction after this one:
- ![[Pasted image 20250211164638.png]]
- for this reason we put the breakpoint here and we remove the previous one
- ![[Pasted image 20250211164707.png]]

We go one step after:
- ![[Pasted image 20250211164719.png]]


At this point to get the `lpBuffer` we have to count 3 instruction before the call:
- since the `lpBuffer` is the third that is charged if we go back from the call
- ![[Pasted image 20250211164912.png]]
- `mov r8,rcx` is the instruction we need


So to extract the data we go on this instruction and we click on `follow in dump` -> `r8`:
- ![[Pasted image 20250211165042.png]]
- ![[Pasted image 20250211165111.png]]


We select it untill we reach `00...` and we save it in a file:
- ![[Pasted image 20250211165312.png]]
- ![[Pasted image 20250211165333.png]]


At this point we use `scdbg`

## Using scdbg
```powershell 
scdbg /f malicious.bin -s -1
```
- ![[Pasted image 20250211165839.png]]

We can see the shellcode calls, and so the malicious content.

