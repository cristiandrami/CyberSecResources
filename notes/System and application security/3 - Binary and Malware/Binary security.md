

# C is an high level language
The C language could be defined as an high level language since it gives an high level of abstraction with respect to the harware, also if ==**developers need to manage by their self the memory allocation and deallocation**==.

<mark style="background: #BBFABBA6;">The memory allocated referes to the heap memory that has a fixed size on the machine.</mark>

The syscalls:
- `brk`
- `sbrk`
Are used to manage the dynamic memory used by C and with them is possible to move the program brake.

**==The program break is the limit of the heap memory assigned to the program.==** With the usage of `brk` and `sbrk` it is possible to request more memory.

![[Pasted image 20240515170854.png]]

C provides a abstraction to simplify the allocation/deallocation of dynamic memory, hiding te complex details:
![[Pasted image 20240515170937.png]]




**==In general the entire memory that can be used is mapped to a virtual memory, that referes to all the usable memories==**.

Generally we have to consider that the more near is the memory the faster the computation:
![[Pasted image 20240515171201.png]]
- The CPU cache is the fastest one (it is in the CPU)
- Then we have the RAM memory
- Then the disk memory (NVRAM)



In this image you can see an idea of how the memory is allocated for dynamic objects in C:
![[Pasted image 20240515171410.png]]


But when we deallocate a memory space we have to consider that  the future allocation of objects depends on the use case and in the approach used by the libraries used to allocate dynamic memory:
![[Pasted image 20240515171538.png]]
- Here we can see that the object obj5 can be allocated in 2 different slots, the slot chosen depends on the implementation of the libraries used.


# Glibc malloc theory 

## Chunks structure
**==The meory allocation is based on the using of internal chunks.==** 
A chunk is basically a struct that contains:
![[Pasted image 20240515171819.png]]
- `mchunck_prev_size` contains the size of the previous chunk in memory
- `mchink_size` contains the size of the `malloc_chuck` that we are considering
- since `malloc_chunk` is based on double-linked list:
	- `fd` represents the next chunk
	- `bk` represents the previous chunk
	- `fd_nextsize` represents the size of the next chunk
		- it is used only when the next chunk is free
	- `bk_nextsize` represents the size of the previous chunk




**==The size is stored into 8 byte and the last lower 3 bits are used to store useful information as:==**
- **==A (main thread)==** -> to understant if the chuck is allocated for the main thread of the program
- **==M  (obtained with mmap)==** -> to understand if the chunk is obtained using `mmap()` 
- **==P (previous in use)==** -> says if the previous chunk is in use or not

![[Pasted image 20240515172959.png]]


## Bins to manage freed chunks

When a chunk is freeded using `free`, **==glibc uses "bins" to manage these freeded chunks==**.

We have different typoplogies of bins:
- **==TCache (Thread cache)==** -> it is a LIFO cache that uses only the `fd` pointer. **It is limited in memory and is used to store only small data.**
	- this is the fastest one
- **==Unsorted Bins==** -> **used for chunck freeded but not assigned yet to other memory blocks requested**
	- it is not ordered by the size (so unsorted)
- ==**Fast Bins**== -> **they are used for small chunks ( < 1024 bytes )**
	- they are implemented as single linked lists 
- **==Small/Large Bins==** -> **They are double linked** 




## GDB / gef useful commands fo the heap

![[Pasted image 20240515173824.png]]
- `heap chunks`  shows the allocated chunks
- `heap bins` shows the bins and so the deallocated chunks


# Memory attacks and problems

## Use-After-Free
**==This is a vulnerability that is present when a program tries to access or use a memory area that was deallocated before using==** **`free`**:
![[Pasted image 20240515193158.png]]
This is very dangerous because:
- **since the memory is stored into the** `heap` **==the OS doesn't notice this problem. This because the access is seen as legit.==**
- no one can say what it would happen, it can be a crash, data corruption or other stuffs
- **==the prevention requires stric rules on pointers==** 
	- *for example MISRA C rules -> guide lines for C code developping*

## VTables in C++
In C++ the situation is a little bit different because we can use objects.
![[Pasted image 20240515193528.png]]
As in Java and Python to each method the `this` pointer is passed.

**==When a method is virtual then the location of the methods are stored into a lookup table called==** `vtable`
- the pointer to the `vtable` **==is stored with the object on the heap==**

To Hijack the control flow we need here to:
1. <mark style="background: #FF5582A6;"> overwrite the vtable pointer </mark>
2. <mark style="background: #FF5582A6;">point to a malicious vtable</mark>
3. <mark style="background: #FF5582A6;">call the virtual function in order to trigger the malicious vtable</mark>



Let's imagine:
```C++
#include <iostream>

class B
{
public:
  virtual void bar();
  virtual void qux();
};

void B::bar()
{
  std::cout << "This is B's implementation of bar" << std::endl;
}

void B::qux()
{
  std::cout << "This is B's implementation of qux" << std::endl;
}


```

And then:
```C++
class C : public B
{
public:
  void bar() override;
};

void C::bar()
{
  std::cout << "This is C's implementation of bar" << std::endl;
}

```

![[Pasted image 20240515194010.png]]



# Other heap exploits

The main goal is the code execution by using the hijacking control flow.

And we can have:
- arbitrary read/write helps
	- rewrite GOT if partial/no RELRO is present
	- rewrite `malloc_hook` or similar, only possible in `glibc <2.34`


## vtable override
**==It is possible when we have classes that uses polimorfism and use the virtual methods.==**

Overriding these tables we can:
- dump shellcode into the heap
- call directly libc functions (*for example `mprotect`*)

(See the code example)


## Glibc malloc hook
==**This is a debugging "feature" in glibc not more present.**
**They were used to allow the modification of the function used to manage the memory, in order to  allows a debug and so on.**==

It was removed in 2.34 

## Stack pivot
**==The idea here is that, when we have little space to construct ROP chains on the stack we can build gadgets on the heap.==**


## Heap Spraying
**==It requires to allocate many objects with the shellcode (so we spary the memory with those objects).==**
- in order to inject this shellcode in memory location that will be executed

Not feasible but can be helpful if the memory range is known.

It is not a heap vulnerability, we just use this approach to make memory corruption exploitable.

<mark style="background: #BBFABBA6;">Protection -> ASRL</mark>

## JIT Spraying 
With the JIT spraying we can let the executable code be generated.
What we generally inject here are ROP gadgets.

<mark style="background: #BBFABBA6;">Protection -> ASRL, Control Flow integrity </mark>


## Heap Feng Shui
**==It is based on the alignment of objects on the heap with precision.==**

Differently from the heap spraying here we inject the memory in a precise way, in order to make the exploit work.

<mark style="background: #BBFABBA6;">Protection -> ASRL</mark>


# Safe linking to the defense?
**==The idea is to mask the forward==** (`fd`) **==pointers of the free chunks with the memory location these location right-shifted by 12.==**
- <mark style="background: #FF5582A6;">this can be used only for</mark> `tcache` and `fastbins` <mark style="background: #FF5582A6;">since they use a single linked-list</mark>

Then `malloc/free` check the integrity of these pointers.

The exploitation is a bit more difficult but not impossible.

![[Pasted image 20240520120603.png]]



# Protections and alternatives

<mark style="background: #BBFABBA6;">We can use runtime checks.</mark>

We can also use **==Pointer Authentication Code==** that:
- is an Hardware Primitive on ARM 
- **==signs the higher bits of a pointer==**
- uses this authentication on specific context

