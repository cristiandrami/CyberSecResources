

# C is an high level language
The C language could be defined as an high level language since it gives an high level of abstraction with respect to the harware, also if ==**developers need to manage by their self the memory allocation and deallocation**==.

The memory allocated referes to the heap memory that has a fixed size on the machine.

The syscalls:
- `brk`
- `sbrk`
Are used to manage the dynamic memory used by C and with them is possible to move the prgram brake.

The program break is the limit of the heap memory assigned to the program. With the usage of `brk` and `sbrk` it is possible to request more memory.

![[Pasted image 20240515170854.png]]

C provides a abstraction to simplify the allocation/deallocation of dynamic memory, hiding te complex details:
![[Pasted image 20240515170937.png]]




In general the entire memory that can be used is mapped to a virtual memory, that referes to all the usable memories.

Generally we have to consider that the more near is the memory the faster the computation:
![[Pasted image 20240515171201.png]]
- The CPU cache is the fastest one (it is in the CPU)
- Then we have the RAM memory
- Then the disk memory (NVRAM)



In this image you can see an idea of how the memory is allocated for dynamic objects in C:
![[Pasted image 20240515171410.png]]


But when we deallocate a memory space we have to consider that  the future allocation of objects depends on the use case and in the approach used by the libraries used to allocate dynamic memory:
![[Pasted image 20240515171538.png]]
- Here we can see that the object obj5 can be allocated in 2 different slots, the slot chosen depends on the implementation of the libraries used.


# Glibc malloc theory 

## Chunks structure
The meory allocation is based on the using of internal chunks. 
A chunk is basically a struct taht contains:
![[Pasted image 20240515171819.png]]
- `mchunck_prev_size` contains the size of the previous chunk in memory
- `mchink_size` contains the size of the `malloc_chuck` that we are considering
- since `malloc_chunk` is based on double-linked list:
	- `fd` represents the next chunk
	- `bk` represents the previous chunk
	- `fd_nextsize` represents the size of the next chunk
		- it is used only when the next chunk is free
	- `bk_nextsize` represents the size of the previous chunk




The size is stored into 8 byte and the last lower 3 bits are used to store useful information as:
- A (main thread) -> to understant if the chuck is allocated for the main thread of the program
- M  (obtained with mmap) -> to understand if the chunk is obtained using `mmap()` 
- P (previous in use) -> says if the previous chunk is in use or not

![[Pasted image 20240515172959.png]]


## Bins to manage freed chunks

When a chunk is freeded using `free`, glibc uses "bins" to manage these chunks.

We have different typoplogies of bins:
- TCache (Thread cache) -> it is a LIFO cache that uses only the `fd` pointer. It is limited in memory and is used to store only small data.
	- this is the fastest one
- Unsorted Bins -> used for chunck freeded but not assigned yet to other memory blocks requested
	- it is not ordered by the size (so unsorted)
- Fast Bins -> they are used for small chunks ( < 1024 bytes )
	- they are implemented as single linked lists 
- Small/Large Bins -> They are double linked 




## GDB / gef useful commands fo the heap

![[Pasted image 20240515173824.png]]
- `heap chunks`  shows the allocated chunks
- `heap bins` shows the bins and so the deallocated chunks


# Memory attacks and problems

## Use-After-Free
This is a vulnerability that is present when a program tries to access or use a memory area that was deallocated before using `free`:
![[Pasted image 20240515193158.png]]
This is very dangerous because:
- since the memory is stored into the `heap` the OS doesn't notice this problem. This because the access is seen as legit.
- no one can say what it would happen, it can be a crash, data corruption or other stuffs
- the prevention requires stric rules on pointers 
	- *for example MISRA C rules -> guide lines for C code developping*

## VTables in C++
In C++ the situation is a little bit different because we can use objects.
![[Pasted image 20240515193528.png]]
As in Java and Python to each method the `this` pointer is passed.

When a method is virtual then the location of the methods are stored into a lookup table called `vtable`
- the pointer to the `vtable` is stored with the object on the heap

To Hijack the control flow we need here to:
1. overwrite the vtable pointer 
2. point to a malicious vtable
3. call the virtual function in order to trigger the malicious vtable



Let's imagine:
```C++
#include <iostream>

class B
{
public:
  virtual void bar();
  virtual void qux();
};

void B::bar()
{
  std::cout << "This is B's implementation of bar" << std::endl;
}

void B::qux()
{
  std::cout << "This is B's implementation of qux" << std::endl;
}


```

And then:
```C++
class C : public B
{
public:
  void bar() override;
};

void C::bar()
{
  std::cout << "This is C's implementation of bar" << std::endl;
}

```

![[Pasted image 20240515194010.png]]



# Other heap exploits

The main goal is the code execution by using the hijacking control flow.

And we can have:
- arbitrary read/write helps
	- rewrite GOT if partial/no RELRO is present
	- rewrite `malloc_hook` or similar, only possible in `glibc <2.34`
- vtable override
	- we can dump shellcode into the heap
	- we can call directly libc functions (*for example `mprotect`*)


## Glibc malloc hook
This is a debugging "feature" in glibc not more present.
It was removed in 2.34 

## Stack pivot
The idea here is that, when we have little space to construct ROP chains on the stack we can build gadgets on the heap.


## Heap Spraying
